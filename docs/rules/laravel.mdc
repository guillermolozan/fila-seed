---
alwaysApply: false
---
# Reglas y Mejores PrÃ¡cticas para Laravel 11

# Reglas de Desarrollo Laravel

## Convenciones de CÃ³digo
- Usar PSR-4 autoloading
- Seguir convenciones de Laravel para nombres de archivos y directorios
- Usar Eloquent ORM para operaciones de base de datos
- Implementar validaciÃ³n en Form Requests cuando sea apropiado
- Usar Resource Controllers para operaciones CRUD estÃ¡ndar

## Filament y LibrerÃ­as
- Crear recursos usando `php artisan make:filament-resource`
- Crear pÃ¡ginas usando `php artisan make:filament-page`
- Seguir las mejores prÃ¡cticas de Filament para formularios y tablas
- Usar polÃ­ticas de autorizaciÃ³n con **Filament Shield** (`bezhansalleh/filament-shield`)
- Implementar editor de texto rico con **Filament TinyEditor** (`amidesfahani/filament-tinyeditor`)
- Usar **Laravel Tinker** (`tinker`) para debugging y exploraciÃ³n de datos

## Base de Datos
- Crear migraciones con `php artisan make:migration`
- Usar seeders para datos de prueba
- Implementar factories para testing

## ğŸ“‹ Estructura del Proyecto CRM Incapower

### OrganizaciÃ³n de Directorios
```
app/
â”œâ”€â”€ Console/           # Comandos Artisan personalizados
â”œâ”€â”€ Exceptions/        # Manejo de excepciones
â”œâ”€â”€ Filament/          # Panel administrativo Filament
â”œâ”€â”€ Helpers/           # Funciones helper personalizadas
â”œâ”€â”€ Http/              # Controladores, middleware, requests
â”œâ”€â”€ Livewire/          # Componentes Livewire
â”œâ”€â”€ Models/            # Modelos Eloquent
â”œâ”€â”€ Policies/          # PolÃ­ticas de autorizaciÃ³n
â”œâ”€â”€ Providers/         # Proveedores de servicios
â”œâ”€â”€ Services/          # LÃ³gica de negocio
â””â”€â”€ View/              # Vistas Blade
```

## ğŸ¯ Reglas Generales

### 1. Nomenclatura y Convenciones
- **Modelos**: Nombres en inglÃ©s, singular y PascalCase (ej: `User`, `Client`, `Service`)
- **Controladores**: Sufijo `Controller` (ej: `ClientController`, `UserController`)
- **Migrations**: Nombres descriptivos con timestamp (ej: `2024_01_15_create_clients_table`)
- **Seeders**: Sufijo `Seeder` (ej: `ClientSeeder`, `UserSeeder`)
- **Factories**: Sufijo `Factory` (ej: `ClientFactory`, `UserFactory`)

### 2. EstÃ¡ndares de CÃ³digo
- Usar PSR-12 para estilo de cÃ³digo
- Implementar Laravel Pint para formateo automÃ¡tico
- Seguir convenciones de Laravel para nombres de mÃ©todos y propiedades

## ğŸ—ï¸ Arquitectura y Patrones

### 1. Estructura de Modelos
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

class Client extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'email',
        'phone',
        'seller_id',
        'status',
        'contact_method_id',
        'geo_province_id',
        'geo_department_id',
        'geo_district_id',
    ];

    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime'
    ];

    // Relaciones
    public function seller(): BelongsTo
    {
        return $this->belongsTo(UserSeller::class, 'seller_id');
    }

    public function activities(): HasMany
    {
        return $this->hasMany(Activity::class);
    }

    public function province(): BelongsTo
    {
        return $this->belongsTo(GeoProvince::class, 'geo_province_id');
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeForSeller($query, $sellerId)
    {
        return $query->where('seller_id', $sellerId);
    }

    // Accessors y Mutators
    public function getFullAddressAttribute(): string
    {
        return collect([
            $this->province?->name,
            $this->department?->name,
            $this->district?->name,
        ])->filter()->implode(', ');
    }
}
```

### 2. Servicios y LÃ³gica de Negocio
```php
<?php

namespace App\Services;

use App\Models\Client;
use App\Models\Activity;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class ClientService
{
    public function createClientWithActivities(array $data): Client
    {
        return DB::transaction(function () use ($data) {
            // Crear cliente
            $client = Client::create($data);
            
            // Crear actividad inicial
            Activity::create([
                'client_id' => $client->id,
                'description' => 'Cliente creado',
                'type' => 'creation',
                'user_id' => auth()->id(),
            ]);

            // Enviar email de bienvenida
            $this->sendWelcomeEmail($client);
            
            Log::info('Cliente creado', ['client_id' => $client->id]);
            
            return $client;
        });
    }

    public function reassignClient(Client $client, int $newSellerId): bool
    {
        try {
            $oldSellerId = $client->seller_id;
            
            $client->update(['seller_id' => $newSellerId]);
            
            // Registrar actividad de reasignaciÃ³n
            Activity::create([
                'client_id' => $client->id,
                'description' => "Cliente reasignado de vendedor {$oldSellerId} a {$newSellerId}",
                'type' => 'reassignment',
                'user_id' => auth()->id(),
            ]);
            
            return true;
        } catch (\Exception $e) {
            Log::error('Error al reasignar cliente', [
                'client_id' => $client->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    private function sendWelcomeEmail(Client $client): void
    {
        // Implementar envÃ­o de email
    }
}
```

## ğŸ” AutenticaciÃ³n y AutorizaciÃ³n

### 1. PolÃ­ticas de Usuario
```php
<?php

namespace App\Policies;

use App\Models\User;
use App\Models\Client;
use Illuminate\Auth\Access\HandlesAuthorization;

class ClientPolicy
{
    use HandlesAuthorization;

    public function viewAny(User $user): bool
    {
        return $user->hasAnyRole(['supermaster', 'master', 'jefe_nacional', 'supervisor', 'jefe', 'vendedor']);
    }

    public function view(User $user, Client $client): bool
    {
        if ($user->hasRole(['supermaster', 'master'])) {
            return true;
        }

        if ($user->hasRole('vendedor')) {
            return $client->seller_id === $user->id;
        }

        // LÃ³gica para otros roles
        return $this->canAccessClient($user, $client);
    }

    public function create(User $user): bool
    {
        return $user->hasAnyRole(['supermaster', 'master', 'jefe', 'vendedor']);
    }

    public function update(User $user, Client $client): bool
    {
        if ($user->hasRole(['supermaster', 'master'])) {
            return true;
        }

        if ($user->hasRole('vendedor')) {
            return $client->seller_id === $user->id;
        }

        return $this->canAccessClient($user, $client);
    }

    private function canAccessClient(User $user, Client $client): bool
    {
        // Implementar lÃ³gica especÃ­fica por rol
        return false;
    }
}
```

### 2. Middleware de AutorizaciÃ³n
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class CheckUserRole
{
    public function handle(Request $request, Closure $next, ...$roles)
    {
        if (!Auth::check()) {
            return redirect()->route('login');
        }

        $user = Auth::user();
        
        if (!$user->hasAnyRole($roles)) {
            abort(403, 'Acceso no autorizado');
        }

        return $next($request);
    }
}
```

## ğŸ—„ï¸ Base de Datos y Migraciones

### 1. Estructura de Migraciones
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('clients', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->string('phone')->nullable();
            $table->foreignId('seller_id')->constrained('user_sellers')->onDelete('cascade');
            $table->string('status')->default('active');
            $table->foreignId('contact_method_id')->constrained('contact_methods');
            $table->foreignId('geo_province_id')->constrained('geo_provinces');
            $table->foreignId('geo_department_id')->constrained('geo_departments');
            $table->foreignId('geo_district_id')->constrained('geo_districts');
            $table->text('notes')->nullable();
            $table->timestamps();
            $table->softDeletes();
            
            // Ãndices para optimizaciÃ³n
            $table->index(['seller_id', 'status']);
            $table->index(['email']);
            $table->index(['created_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('clients');
    }
};
```

### 2. Seeders y Factories
```php
<?php

namespace Database\Seeders;

use App\Models\Client;
use App\Models\UserSeller;
use App\Models\GeoProvince;
use App\Models\ContactMethod;
use Illuminate\Database\Seeder;

class ClientSeeder extends Seeder
{
    public function run(): void
    {
        $sellers = UserSeller::all();
        $provinces = GeoProvince::all();
        $contactMethods = ContactMethod::all();

        Client::factory(100)->create()->each(function ($client) use ($sellers, $provinces, $contactMethods) {
            $client->update([
                'seller_id' => $sellers->random()->id,
                'geo_province_id' => $provinces->random()->id,
                'contact_method_id' => $contactMethods->random()->id,
            ]);
        });
    }
}
```

## ğŸš€ API y Respuestas

### 1. Controladores de API
```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Client;
use App\Http\Resources\ClientResource;
use App\Http\Requests\ClientRequest;
use App\Services\ClientService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class ClientApiController extends Controller
{
    public function __construct(
        private ClientService $clientService
    ) {}

    public function index(Request $request): JsonResponse
    {
        $clients = Client::query()
            ->when($request->search, function ($query, $search) {
                $query->where('name', 'like', "%{$search}%")
                      ->orWhere('email', 'like', "%{$search}%");
            })
            ->when($request->seller_id, function ($query, $sellerId) {
                $query->where('seller_id', $sellerId);
            })
            ->with(['seller', 'province', 'department', 'district'])
            ->paginate($request->per_page ?? 15);

        return response()->json([
            'data' => ClientResource::collection($clients),
            'meta' => [
                'current_page' => $clients->currentPage(),
                'last_page' => $clients->lastPage(),
                'per_page' => $clients->perPage(),
                'total' => $clients->total(),
            ],
        ]);
    }

    public function store(ClientRequest $request): JsonResponse
    {
        try {
            $client = $this->clientService->createClientWithActivities($request->validated());
            
            return response()->json([
                'message' => 'Cliente creado exitosamente',
                'data' => new ClientResource($client),
            ], 201);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Error al crear cliente',
                'error' => $e->getMessage(),
            ], 500);
        }
    }
}
```

### 2. Requests de ValidaciÃ³n
```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class ClientRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true; // La autorizaciÃ³n se maneja en las polÃ­ticas
    }

    public function rules(): array
    {
        $clientId = $this->route('client');
        
        return [
            'name' => ['required', 'string', 'max:255'],
            'email' => [
                'required',
                'email',
                Rule::unique('clients')->ignore($clientId),
            ],
            'phone' => ['nullable', 'string', 'max:20'],
            'seller_id' => ['required', 'exists:user_sellers,id'],
            'status' => ['required', 'in:active,inactive,prospect,client'],
            'contact_method_id' => ['required', 'exists:contact_methods,id'],
            'geo_province_id' => ['required', 'exists:geo_provinces,id'],
            'geo_department_id' => ['required', 'exists:geo_departments,id'],
            'geo_district_id' => ['required', 'exists:geo_districts,id'],
            'notes' => ['nullable', 'string', 'max:1000'],
        ];
    }

    public function messages(): array
    {
        return [
            'name.required' => 'El nombre es obligatorio',
            'email.required' => 'El email es obligatorio',
            'email.email' => 'El email debe tener un formato vÃ¡lido',
            'email.unique' => 'Este email ya estÃ¡ registrado',
            'seller_id.required' => 'Debe seleccionar un vendedor',
            'seller_id.exists' => 'El vendedor seleccionado no existe',
        ];
    }
}
```

## ğŸ“Š Jobs y Colas

### 1. Jobs AsÃ­ncronos
```php
<?php

namespace App\Jobs;

use App\Models\Client;
use App\Services\EmailService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class SendClientWelcomeEmail implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        private Client $client
    ) {}

    public function handle(EmailService $emailService): void
    {
        try {
            $emailService->sendWelcomeEmail($this->client);
            
            Log::info('Email de bienvenida enviado', [
                'client_id' => $this->client->id,
                'email' => $this->client->email,
            ]);
        } catch (\Exception $e) {
            Log::error('Error al enviar email de bienvenida', [
                'client_id' => $this->client->id,
                'error' => $e->getMessage(),
            ]);
            
            throw $e;
        }
    }

    public function failed(\Throwable $exception): void
    {
        Log::error('Job de email fallÃ³', [
            'client_id' => $this->client->id,
            'error' => $exception->getMessage(),
        ]);
    }
}
```

### 2. ConfiguraciÃ³n de Colas
```php
// config/queue.php
'default' => env('QUEUE_CONNECTION', 'redis'),

'connections' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => env('REDIS_QUEUE', 'default'),
        'retry_after' => 90,
        'block_for' => null,
    ],
],
```

## ğŸ”§ ConfiguraciÃ³n y OptimizaciÃ³n

### 1. ConfiguraciÃ³n de CachÃ©
```php
// config/cache.php
'default' => env('CACHE_DRIVER', 'redis'),

'stores' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'cache',
        'lock_connection' => 'default',
    ],
],
```

### 2. OptimizaciÃ³n de Consultas
```php
// En modelos, usar with() para eager loading
public static function getClientsWithRelations()
{
    return static::with([
        'seller',
        'province',
        'department',
        'district',
        'activities' => function ($query) {
            $query->latest()->limit(5);
        },
    ])->get();
}

// Usar Ã­ndices en base de datos
// Implementar cachÃ© para consultas costosas
public function getActiveClientsCount(): int
{
    return Cache::remember('active_clients_count', 3600, function () {
        return $this->where('status', 'active')->count();
    });
}
```

## ğŸ§ª Testing

### 1. Tests de Modelos
```php
<?php

namespace Tests\Unit;

use App\Models\Client;
use App\Models\UserSeller;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class ClientTest extends TestCase
{
    use RefreshDatabase;

    public function test_can_create_client(): void
    {
        $seller = UserSeller::factory()->create();
        
        $clientData = [
            'name' => 'Juan PÃ©rez',
            'email' => 'juan@example.com',
            'phone' => '123456789',
            'seller_id' => $seller->id,
            'status' => 'active',
            // ... otros campos requeridos
        ];

        $client = Client::create($clientData);

        $this->assertInstanceOf(Client::class, $client);
        $this->assertEquals('Juan PÃ©rez', $client->name);
        $this->assertEquals('juan@example.com', $client->email);
    }

    public function test_client_belongs_to_seller(): void
    {
        $seller = UserSeller::factory()->create();
        $client = Client::factory()->create(['seller_id' => $seller->id]);

        $this->assertInstanceOf(UserSeller::class, $client->seller);
        $this->assertEquals($seller->id, $client->seller->id);
    }
}
```

### 2. Tests de API
```php
<?php

namespace Tests\Feature;

use App\Models\Client;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class ClientApiTest extends TestCase
{
    use RefreshDatabase;

    public function test_can_get_clients_list(): void
    {
        $user = User::factory()->create();
        $clients = Client::factory(5)->create();

        $response = $this->actingAs($user)
            ->getJson('/api/clients');

        $response->assertStatus(200)
                ->assertJsonCount(5, 'data');
    }
}
```

## ğŸš¨ Seguridad y ValidaciÃ³n

### 1. SanitizaciÃ³n de Datos
```php
// En modelos, usar mutators para sanitizar
public function setNameAttribute($value): void
{
    $this->attributes['name'] = ucwords(strtolower(trim($value)));
}

public function setEmailAttribute($value): void
{
    $this->attributes['email'] = strtolower(trim($value));
}
```

### 2. ProtecciÃ³n CSRF
```php
// En web.php, todas las rutas web tienen protecciÃ³n CSRF automÃ¡tica
// Para APIs, usar middleware 'api' que no requiere CSRF
```

## ğŸ“ Logging y Monitoreo

### 1. ConfiguraciÃ³n de Logs
```php
// config/logging.php
'channels' => [
    'stack' => [
        'driver' => 'stack',
        'channels' => ['single', 'daily'],
        'ignore_exceptions' => false,
    ],
    'daily' => [
        'driver' => 'daily',
        'path' => storage_path('logs/laravel.log'),
        'level' => env('LOG_LEVEL', 'debug'),
        'days' => 14,
    ],
],
```

### 2. Logging Personalizado
```php
// En servicios y controladores
Log::channel('daily')->info('Cliente creado', [
    'client_id' => $client->id,
    'user_id' => auth()->id(),
    'ip_address' => request()->ip(),
]);

Log::channel('daily')->error('Error en proceso', [
    'error' => $e->getMessage(),
    'stack_trace' => $e->getTraceAsString(),
]);
```

## ğŸ”„ Comandos Artisan

### 1. Comandos Personalizados
```php
<?php

namespace App\Console\Commands;

use App\Models\Client;
use App\Services\ClientService;
use Illuminate\Console\Command;

class ProcessClientFollowUps extends Command
{
    protected $signature = 'clients:process-follow-ups';
    protected $description = 'Procesar seguimientos de clientes pendientes';

    public function handle(ClientService $clientService): int
    {
        $this->info('Procesando seguimientos de clientes...');

        $pendingClients = Client::where('status', 'prospect')
            ->where('last_activity_at', '<=', now()->subDays(7))
            ->get();

        $bar = $this->output->createProgressBar($pendingClients->count());

        foreach ($pendingClients as $client) {
            $clientService->createFollowUpActivity($client);
            $bar->advance();
        }

        $bar->finish();
        $this->newLine();
        $this->info("Procesados {$pendingClients->count()} clientes");

        return Command::SUCCESS;
    }
}
```

## ğŸ“š Recursos Adicionales

### 1. Paquetes Utilizados
- `laravel/framework`: Framework principal
- `laravel/tinker`: REPL para desarrollo
- `laravel/sail`: Entorno Docker para desarrollo
- `laravel/pint`: Formateador de cÃ³digo

### 2. Enlaces Ãštiles
- [DocumentaciÃ³n oficial de Laravel](https://laravel.com/docs)
- [Laravel Best Practices](https://github.com/alexeymezenin/laravel-best-practices)
- [Laravel Testing](https://laravel.com/docs/testing)

---

**Nota**: Este documento debe actualizarse conforme evolucione el proyecto y se implementen nuevas funcionalidades. Mantener consistencia con las reglas de Filament para una integraciÃ³n Ã³ptima.

